<!doctype html>
<html lang="en">
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Coast2Coast 2025</title>
    <style>
        body {
            font-family: system-ui, sans-serif;
            margin: 0;
            background: #0b1020;
            color: #f5f6fa;
            display: flex;
            flex-direction: column;
            min-height: 100vh;
        }
        header {
            background: #111731;
            padding: 1rem;
            text-align: center;
            position: sticky;
            top: 0;
            z-index: 10;
        }
        h1 {
            margin: 0;
            font-size: 1.2rem;
        }
        .date-display-top {
            font-size: 1rem;
            font-weight: bold;
            text-align: center;
            margin-top: 0.5rem;
            color: #9fb1d8;
        }
        .progress-display {
            font-size: 0.9rem;
            color: #4caf50;
            margin-top: 0.5rem;
            font-weight: 600;
        }
        .wrap {
            padding: 1rem;
            flex-grow: 1;
        }
        h2 {
            font-size: 1.1rem;
            margin-top: 1.5rem;
            margin-bottom: 0.5rem;
            border-bottom: 1px solid #2a3561;
            padding-bottom: 0.25rem;
        }
        .card {
            background: #1a2142;
            padding: 1rem;
            border-radius: 12px;
            margin-bottom: 0.75rem;
            border: 1px solid #2a3561;
            position: relative;
        }
        .time {
            font-weight: bold;
            font-size: 1rem;
        }
        .title {
            font-size: 1.1rem;
            font-weight: bold;
            margin-top: 0.25rem;
        }
        .details {
            margin-top: 0.5rem;
            font-size: 0.9rem;
        }
        .detail-row {
            margin-bottom: 0.25rem;
        }
        .detail-label {
            color: #9fb1d8;
            font-weight: 600;
            margin-right: 0.5rem;
        }
        .clickable-location {
            color: #6da2f8;
            text-decoration: underline;
            cursor: pointer;
        }
        .empty {
            padding: 1rem;
            border: 1px dashed #2a3561;
            border-radius: 12px;
            text-align: center;
            color: #9fb1d8;
        }
        .current {
            border: 2px solid #4a90e2;
            box-shadow: 0 0 8px #4a90e2;
        }
        .checkbox {
            position: absolute;
            top: 0.75rem;
            right: 0.75rem;
        }
        input[type="checkbox"] {
            transform: scale(1.3);
        }
        .navigation {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0.5rem 1rem;
            background: #111731;
            position: sticky;
            bottom: 0;
            z-index: 9;
            border-top: 1px solid #2a3561;
            box-shadow: 0 -2px 5px rgba(0, 0, 0, 0.2);
        }
        .nav-button {
            background: #2a3561;
            color: #f5f6fa;
            border: none;
            padding: 0.5rem 1rem;
            border-radius: 8px;
            cursor: pointer;
            font-size: 1rem;
        }
        .nav-button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        .date-display-bottom {
            font-size: 1.1rem;
            font-weight: bold;
            flex-grow: 1;
            text-align: center;
        }
        .date-display-bottom.hidden {
            display: none;
        }
        .countdown-container {
            text-align: center;
            padding: 2rem;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            height: 100%;
        }
        .countdown-message {
            font-size: 1.5rem;
            font-weight: bold;
            color: #4a90e2;
            margin-bottom: 1rem;
        }
        #countdownTimer {
            font-size: 1.5rem;
            font-weight: bold;
            color: #f5f6fa;
            margin-bottom: 1.5rem;
            background: #1a2142;
            padding: 1rem;
            border-radius: 12px;
            border: 1px solid #2a3561;
            box-shadow: 0 0 15px rgba(74, 144, 226, 0.5);
            white-space: pre-wrap;
        }
        .countdown-button {
            background: #4a90e2;
            color: white;
            border: none;
            padding: 0.75rem 1.5rem;
            border-radius: 8px;
            font-size: 1rem;
            cursor: pointer;
            transition: background 0.3s;
        }
        .countdown-button:hover {
            background: #3973b7;
        }
    </style>
</head>
<body>
    <header>
        <h1>Coast2Coast 2025</h1>
        <div id="dateDisplayTop" class="date-display-top"></div>
        <div id="progressDisplay" class="progress-display"></div>
    </header>
    <div id="appContainer" class="wrap">
        <div id="itineraryView">
            <div id="list"></div>
        </div>
        <div id="countdownView" style="display:none;">
            <div class="countdown-container">
                <div class="countdown-message">Countdown to start</div>
                <div id="countdownTimer"></div>
                <button id="backBtn" class="countdown-button">Back to Itinerary</button>
            </div>
        </div>
        <div id="completedView" style="display:none;">
            <h2>Completed Activities</h2>
            <div id="completedList"></div>
            <button id="backFromCompletedBtn" class="countdown-button">Back to Itinerary</button>
        </div>
        <div id="nextStopsView" style="display:none;">
            <h2>Upcoming Stops</h2>
            <div id="nextStopsList"></div>
            <button id="backFromNextBtn" class="countdown-button">Back to Itinerary</button>
        </div>
    </div>
    <div class="navigation">
        <button id="prevBtn" class="nav-button">‚¨ÖÔ∏è</button>
        <button id="todayBtn" class="nav-button">Today</button>
        <button id="completedBtn" class="nav-button">‚úÖ</button>
        <button id="nextStopsBtn" class="nav-button">üß≠</button>
        <button id="nextBtn" class="nav-button">‚û°Ô∏è</button>
    </div>
    <script>
        let grouped = new Map();
        let allDates = [];
        let events = [];
        let currentIndex = 0;
        let countdownInterval;

        /**
         * Parses a date string in Day/Month/Year format.
         * @param {string} dateStr - The date string to parse.
         * @returns {Date|null} The parsed Date object or null if invalid.
         */
        function parseDateDMY(dateStr) {
            if (!dateStr) return null;
            const [d, m, y] = dateStr.split("/").map(x => parseInt(x, 10));
            if (!d || !m || !y) return null;
            return new Date(y, m - 1, d);
        }

        /**
         * Formats a Date object into a DD-MM-YY string.
         * @param {Date} d - The Date object to format.
         * @returns {string} The formatted date string.
         */
        function formatDateDDMMYY(d) {
            const dd = String(d.getDate()).padStart(2, '0');
            const mm = String(d.getMonth() + 1).padStart(2, '0');
            const yy = String(d.getFullYear()).slice(-2);
            return `${dd}-${mm}-${yy}`;
        }
        
        /**
         * Formats a date string for display (e.g., "Monday, August 25, 2025").
         * @param {string} dStr - The date string in DD-MM-YY format.
         * @returns {string} The user-friendly date string.
         */
        function formatDateForDisplay(dStr) {
            const [dd, mm, yy] = dStr.split('-');
            const date = new Date(`20${yy}`, mm - 1, dd);
            const options = { weekday: 'long', year: 'numeric', month: 'long', day: 'numeric' };
            return date.toLocaleDateString('en-US', options);
        }

        /**
         * Converts CSV text into an array of row arrays.
         * @param {string} text - The CSV text.
         * @returns {string[][]} An array of rows.
         */
        function csvToRows(text) {
            const lines = text.trim().split(/\r?\n/);
            return lines.map(line => {
                let inQuote = false;
                let currentItem = '';
                const items = [];
                for(let i = 0; i < line.length; i++) {
                    const char = line[i];
                    if (char === '"') {
                        inQuote = !inQuote;
                    } else if (char === ',' && !inQuote) {
                        items.push(currentItem.trim());
                        currentItem = '';
                    } else {
                        currentItem += char;
                    }
                }
                items.push(currentItem.trim());
                return items;
            });
        }

        /**
         * Parses event data from a custom CSV format.
         * @param {string[][]} rows - The CSV rows.
         * @returns {Array<Object>} An array of event objects.
         */
        function parseEventsFromCustomCSV(rows) {
            const evts = [];
            for (let i = 1; i < rows.length; i++) {
                const r = rows[i];
                if (!r[0]) continue;
                const dt = parseDateDMY(r[0].trim());
                if (!dt) continue;
                const dateStr = formatDateDDMMYY(dt);
                const dep = r[5] || "";
                const arr = r[6] || "";
                const from = r[2] || "";
                const to = r[3] || "";
                const mode = r[4] || "";
                const distance = r[8] || "";
                const activity = from && to ? `${from} ‚Üí ${to}` : (from || to || r[9] || "Activity");
                
                const details = {};
                if (from) details['From'] = from;
                if (to) details['To'] = to;
                if (mode) details['Preferred mode of transport'] = mode;
                if (dep) details['Departure Time'] = dep;
                if (arr) details['Arrival Time'] = arr;
                if (distance) details['Distance'] = distance;
                
                evts.push({ date: dateStr, time: dep || arr || "", activity, details, id: `${dateStr}-${i}` });
            }
            return evts;
        }

        /**
         * Groups events by date.
         * @param {Array<Object>} events - The list of events.
         * @returns {Map<string, Array<Object>>} A map with dates as keys and event arrays as values.
         */
        function groupByDate(events) {
            const map = new Map();
            for (const e of events) {
                if (!map.has(e.date)) map.set(e.date, []);
                map.get(e.date).push(e);
            }
            return map;
        }

        /**
         * Checks if an event is currently happening or will happen soon.
         * @param {Object} evt - The event object.
         * @returns {boolean} True if the event is a current or upcoming one.
         */
        function isNowOrNext(evt) {
            if (!evt.time) return false;
            const [hh, mm] = evt.time.split(":").map(x => parseInt(x, 10));
            if (isNaN(hh)) return false;
            const now = new Date();
            const [dd, mmDate, yy] = evt.date.split('-').map(x => parseInt(x, 10));
            const evtDate = new Date(2000 + yy, mmDate - 1, dd, hh, mm || 0);
            const diff = evtDate - now;
            return diff >= 0 && diff < 2 * 60 * 60 * 1000;
        }

        /**
         * Opens the device's default map app with directions to a specified destination.
         * @param {string} destination - The name of the destination.
         */
        function openInMaps(destination) {
            const url = `https://www.google.com/maps/dir/?api=1&destination=${encodeURIComponent(destination)}`;
            window.open(url, '_blank');
        }

        /**
         * Renders the itinerary for a specific date.
         * @param {string} dateStr - The date string to render.
         */
        function renderDay(dateStr) {
            const list = document.getElementById('list');
            list.innerHTML = '';
            
            const evts = grouped.get(dateStr) || [];
            if (evts.length === 0) {
                list.innerHTML = `<div class="empty">No events scheduled for this day.</div>`;
                return;
            }

            const doneIds = JSON.parse(localStorage.getItem('doneIds') || '[]');
            const remaining = evts.filter(e => !doneIds.includes(e.id));
            
            if (remaining.length === 0) {
                list.innerHTML = `<div class="empty">All events for this day are complete! üéâ</div>`;
                return;
            }

            for (const e of remaining) {
                const card = document.createElement('div');
                card.className = 'card';
                if (isNowOrNext(e)) card.classList.add('current');

                const t = document.createElement('div');
                t.className = 'time';
                t.textContent = e.time || 'All day';

                const title = document.createElement('div');
                title.className = 'title';
                title.textContent = e.activity;

                const detailsDiv = document.createElement('div');
                detailsDiv.className = 'details';

                // Make "From" location clickable
                if(e.details['From']) {
                    const fromRow = document.createElement('div'); 
                    fromRow.className = 'detail-row';
                    fromRow.innerHTML = `<span class="detail-label">From:</span> <span class="clickable-location">${e.details['From']}</span>`;
                    fromRow.querySelector('.clickable-location').addEventListener('click', () => openInMaps(e.details['From']));
                    detailsDiv.appendChild(fromRow);
                }
                // Make "To" location clickable
                if(e.details['To']) {
                    const toRow = document.createElement('div'); 
                    toRow.className = 'detail-row';
                    toRow.innerHTML = `<span class="detail-label">To:</span> <span class="clickable-location">${e.details['To']}</span>`;
                    toRow.querySelector('.clickable-location').addEventListener('click', () => openInMaps(e.details['To']));
                    detailsDiv.appendChild(toRow);
                }
                
                // Add the new "Preferred mode of transport" row
                if(e.details['Preferred mode of transport']) {
                    const modeRow = document.createElement('div');
                    modeRow.className = 'detail-row';
                    modeRow.innerHTML = `<span class="detail-label">Preferred mode of transport:</span> ${e.details['Preferred mode of transport']}`;
                    detailsDiv.appendChild(modeRow);
                }

                if(e.details['Departure Time']) {
                    const depRow = document.createElement('div'); depRow.className = 'detail-row';
                    depRow.innerHTML = `<span class="detail-label">Departure:</span> ${e.details['Departure Time']}`;
                    detailsDiv.appendChild(depRow);
                }
                if(e.details['Arrival Time']) {
                    const arrRow = document.createElement('div'); arrRow.className = 'detail-row';
                    arrRow.innerHTML = `<span class="detail-label">Arrival:</span> ${e.details['Arrival Time']}`;
                    detailsDiv.appendChild(arrRow);
                }
                
                // Add the new "Distance" row
                if(e.details['Distance']) {
                    const distRow = document.createElement('div');
                    distRow.className = 'detail-row';
                    distRow.innerHTML = `<span class="detail-label">Distance:</span> ${e.details['Distance']} miles`;
                    detailsDiv.appendChild(distRow);
                }

                const cb = document.createElement('input');
                cb.type = 'checkbox';
                cb.className = 'checkbox';
                cb.onchange = () => {
                    const ids = JSON.parse(localStorage.getItem('doneIds') || '[]');
                    if (cb.checked && !ids.includes(e.id)) ids.push(e.id);
                    localStorage.setItem('doneIds', JSON.stringify(ids));
                    renderDay(dateStr);
                    updateProgress();
                };
                card.appendChild(cb);
                card.appendChild(t);
                card.appendChild(title);
                card.appendChild(detailsDiv);
                list.appendChild(card);
            }
        }

        /**
         * Renders the list of completed events.
         */
        function renderCompleted() {
            const list = document.getElementById('completedList');
            list.innerHTML = '';

            const doneIds = JSON.parse(localStorage.getItem('doneIds') || '[]');
            const completedEvents = events.filter(e => doneIds.includes(e.id));
            
            if (completedEvents.length === 0) {
                list.innerHTML = `<div class="empty">No completed activities yet.</div>`;
                return;
            }

            for (const e of completedEvents) {
                const card = document.createElement('div');
                card.className = 'card';

                const t = document.createElement('div');
                t.className = 'time';
                t.textContent = e.time || 'All day';

                const title = document.createElement('div');
                title.className = 'title';
                title.textContent = e.activity;

                const detailsDiv = document.createElement('div');
                detailsDiv.className = 'details';

                if(e.details['From']) {
                    const fromRow = document.createElement('div'); 
                    fromRow.className = 'detail-row';
                    fromRow.innerHTML = `<span class="detail-label">From:</span> <span class="clickable-location">${e.details['From']}</span>`;
                    fromRow.querySelector('.clickable-location').addEventListener('click', () => openInMaps(e.details['From']));
                    detailsDiv.appendChild(fromRow);
                }
                if(e.details['To']) {
                    const toRow = document.createElement('div'); 
                    toRow.className = 'detail-row';
                    toRow.innerHTML = `<span class="detail-label">To:</span> <span class="clickable-location">${e.details['To']}</span>`;
                    toRow.querySelector('.clickable-location').addEventListener('click', () => openInMaps(e.details['To']));
                    detailsDiv.appendChild(toRow);
                }
                if(e.details['Preferred mode of transport']) {
                    const modeRow = document.createElement('div');
                    modeRow.className = 'detail-row';
                    modeRow.innerHTML = `<span class="detail-label">Preferred mode of transport:</span> ${e.details['Preferred mode of transport']}`;
                    detailsDiv.appendChild(modeRow);
                }
                if(e.details['Distance']) {
                    const distRow = document.createElement('div');
                    distRow.className = 'detail-row';
                    distRow.innerHTML = `<span class="detail-label">Distance:</span> ${e.details['Distance']} miles`;
                    detailsDiv.appendChild(distRow);
                }

                const cb = document.createElement('input');
                cb.type = 'checkbox';
                cb.className = 'checkbox';
                cb.checked = true; // All items on this page are checked
                cb.onchange = () => {
                    let ids = JSON.parse(localStorage.getItem('doneIds') || '[]');
                    ids = ids.filter(id => id !== e.id);
                    localStorage.setItem('doneIds', JSON.stringify(ids));
                    renderCompleted();
                    updateProgress();
                };
                card.appendChild(cb);
                card.appendChild(t);
                card.appendChild(title);
                card.appendChild(detailsDiv);
                list.appendChild(card);
            }
        }
        
        /**
         * Renders the list of upcoming locations.
         */
        
async function renderNextStops() {
            const list = document.getElementById('nextStopsList');
            list.innerHTML = '<div class="empty">Finding nearby upcoming stops‚Ä¶</div>';

            /***** Helper functions scoped inside renderNextStops to avoid global changes *****/
            const GOOGLE_GEOCODING_API_KEY = ""; // <-- Optionally set your Google Geocoding API key here

            function getCurrentPositionPromise(options = { enableHighAccuracy: true, timeout: 10000 }) {
                return new Promise((resolve, reject) => {
                    if (!navigator.geolocation) return reject(new Error("Geolocation not supported"));
                    navigator.geolocation.getCurrentPosition(
                        pos => resolve({ lat: pos.coords.latitude, lon: pos.coords.longitude }),
                        err => reject(err),
                        options
                    );
                });
            }

            function haversineDistanceMeters(lat1, lon1, lat2, lon2) {
                const toRad = x => x * Math.PI / 180.0;
                const R = 6371000;
                const dLat = toRad(lat2 - lat1);
                const dLon = toRad(lon2 - lon1);
                const a = Math.sin(dLat/2) * Math.sin(dLat/2) +
                          Math.cos(toRad(lat1)) * Math.cos(toRad(lat2)) *
                          Math.sin(dLon/2) * Math.sin(dLon/2);
                const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
                return R * c;
            }

            async function geocodeLocation(location) {
                if (!location) throw new Error("Empty location");
                const cacheKey = 'geocodeCache_v1';
                let cache = {};
                try { cache = JSON.parse(localStorage.getItem(cacheKey) || "{}"); } catch (e) { cache = {}; }
                if (cache[location]) return cache[location];

                let result = null;
                try {
                    if (GOOGLE_GEOCODING_API_KEY && GOOGLE_GEOCODING_API_KEY.trim().length > 0) {
                        const url = `https://maps.googleapis.com/maps/api/geocode/json?address=${encodeURIComponent(location)}&key=${GOOGLE_GEOCODING_API_KEY}`;
                        const res = await fetch(url);
                        const json = await res.json();
                        if (json.status === 'OK' && json.results && json.results.length) {
                            const r = json.results[0];
                            result = { lat: parseFloat(r.geometry.location.lat), lon: parseFloat(r.geometry.location.lng), display_name: r.formatted_address };
                        }
                    } else {
                        // Nominatim (OpenStreetMap) - light usage only. Add &email=you@domain.com if desired.
                        const url = `https://nominatim.openstreetmap.org/search?format=json&q=${encodeURIComponent(location)}&limit=1`;
                        const res = await fetch(url, { headers: { 'Accept-Language': 'en' } });
                        const arr = await res.json();
                        if (Array.isArray(arr) && arr.length) {
                            result = { lat: parseFloat(arr[0].lat), lon: parseFloat(arr[0].lon), display_name: arr[0].display_name };
                        }
                    }
                } catch (err) {
                    console.warn("Geocoding error for", location, err);
                }

                if (!result) throw new Error("Geocode failed");
                cache[location] = result;
                try { localStorage.setItem(cacheKey, JSON.stringify(cache)); } catch (e) { /* ignore storage errors */ }
                return result;
            }
            /***** End helpers *****/

            // Build set of upcoming unvisited locations (reuse existing logic)
            const doneIds = JSON.parse(localStorage.getItem('doneIds') || '[]');
            const today = allDates[currentIndex];
            const upcomingEvents = events.filter(e => {
                const eventDateIndex = allDates.indexOf(e.date);
                const todayIndex = allDates.indexOf(today);
                return eventDateIndex >= todayIndex && !doneIds.includes(e.id);
            });

            const uniqueLocations = new Set();
            for (const event of upcomingEvents) {
                if (event.details['To']) uniqueLocations.add(event.details['To']);
                else if (event.details['From']) uniqueLocations.add(event.details['From']);
            }

            if (uniqueLocations.size === 0) {
                list.innerHTML = `<div class="empty">No upcoming stops to display.</div>`;
                return;
            }

            const locationsToGeocode = Array.from(uniqueLocations).slice(0, 30);

            // Get user's current position
            let userPos;
            try {
                userPos = await getCurrentPositionPromise();
            } catch (err) {
                list.innerHTML = `<div class="empty">Unable to get your location. Please allow location access in your browser to see nearby stops.</div>`;
                return;
            }

            // Geocode (sequentially to be polite)
            const geocoded = [];
            for (const loc of locationsToGeocode) {
                try {
                    const g = await geocodeLocation(loc);
                    if (g && typeof g.lat === 'number' && typeof g.lon === 'number') {
                        const meters = haversineDistanceMeters(userPos.lat, userPos.lon, g.lat, g.lon);
                        geocoded.push({ location: loc, lat: g.lat, lon: g.lon, display_name: g.display_name || loc, meters });
                    }
                } catch (e) {
                    console.warn("Skipping geocode for", loc, e);
                }
            }

            if (geocoded.length === 0) {
                list.innerHTML = `<div class="empty">Could not geocode any upcoming stops.</div>`;
                return;
            }

            // Sort and render
            geocoded.sort((a, b) => a.meters - b.meters);
            const top = geocoded.slice(0, 15);
            list.innerHTML = '';

            for (const item of top) {
                const card = document.createElement('div');
                card.className = 'card';
                const miles = (item.meters / 1609.344);
                const km = (item.meters / 1000);

                card.innerHTML = `
                    <div class="title">${item.location}</div>
                    <div class="details">
                        <div class="detail-row"><span class="detail-label">Distance:</span> ${km.toFixed(1)} km (${miles.toFixed(1)} mi)</div>
                        <div class="detail-row"><span class="detail-label">Place:</span> ${item.display_name}</div>
                        <div class="detail-row"><span class="detail-label">Map:</span> <span class="clickable-location">Get Directions</span></div>
                    </div>
                `;

                card.querySelector('.clickable-location').addEventListener('click', () => {
                    const latlng = `${item.lat},${item.lon}`;
                    const url = `https://www.google.com/maps/dir/?api=1&destination=${encodeURIComponent(latlng)}`;
                    window.open(url, '_blank');
                });

                list.appendChild(card);
            }

            const footer = document.createElement('div');
            footer.className = 'detail-row';
            footer.style.marginTop = '8px';
            footer.style.fontSize = '0.85rem';
            footer.style.color = '#9fb1d8';
            footer.textContent = `Your location: ${userPos.lat.toFixed(5)}, ${userPos.lon.toFixed(5)}`;
            list.appendChild(footer);
        }



        /**
         * Displays the countdown timer view.
         */
        function showCountdown() {
            document.getElementById('itineraryView').style.display = 'none';
            document.getElementById('countdownView').style.display = 'block';
            document.getElementById('completedView').style.display = 'none';
            document.getElementById('nextStopsView').style.display = 'none';
            document.getElementById('dateDisplayTop').style.display = 'none';
            clearInterval(countdownInterval);
            
            const firstDate = new Date(`20${allDates[0].slice(-2)}`, allDates[0].slice(3, 5) - 1, allDates[0].slice(0, 2));
            
            countdownInterval = setInterval(() => {
                const now = new Date().getTime();
                const distance = firstDate.getTime() - now;

                if (distance < 0) {
                    clearInterval(countdownInterval);
                    document.getElementById('countdownTimer').innerHTML = "The trip has begun!";
                    return;
                }

                const week = Math.floor(distance / (1000 * 60 * 60 * 24 * 7));
                const days = Math.floor((distance % (1000 * 60 * 60 * 24 * 7)) / (1000 * 60 * 60 * 24));
                const hours = Math.floor((distance % (1000 * 60 * 60 * 24)) / (1000 * 60 * 60));
                const minutes = Math.floor((distance % (1000 * 60 * 60)) / (1000 * 60));
                const seconds = Math.floor((distance % (1000 * 60)) / 1000);

                document.getElementById('countdownTimer').innerHTML = `${week}w ${days}d\n${hours}h ${minutes}m ${seconds}s`;
            }, 1000);
        }

        /**
         * Displays the itinerary view.
         */
        function showItinerary() {
            clearInterval(countdownInterval);
            document.getElementById('itineraryView').style.display = 'block';
            document.getElementById('countdownView').style.display = 'none';
            document.getElementById('completedView').style.display = 'none';
            document.getElementById('nextStopsView').style.display = 'none';
            document.getElementById('dateDisplayTop').style.display = 'block';
            document.getElementById('progressDisplay').style.display = 'block';
            updateUI();
        }

        /**
         * Displays the completed activities view.
         */
        function showCompleted() {
            clearInterval(countdownInterval);
            document.getElementById('itineraryView').style.display = 'none';
            document.getElementById('countdownView').style.display = 'none';
            document.getElementById('completedView').style.display = 'block';
            document.getElementById('nextStopsView').style.display = 'none';
            document.getElementById('dateDisplayTop').style.display = 'none'; // Hide the date for this view
            document.getElementById('progressDisplay').style.display = 'none';
            renderCompleted();
        }
        
        /**
         * Displays the next stops view.
         */
        function showNextStops() {
            clearInterval(countdownInterval);
            document.getElementById('itineraryView').style.display = 'none';
            document.getElementById('countdownView').style.display = 'none';
            document.getElementById('completedView').style.display = 'none';
            document.getElementById('nextStopsView').style.display = 'block';
            document.getElementById('dateDisplayTop').style.display = 'none'; // Hide the date for this view
            document.getElementById('progressDisplay').style.display = 'none';
            renderNextStops();
        }


        /**
         * Updates the UI with the correct date and buttons state.
         */
        function updateUI() {
            const dateStr = allDates[currentIndex];
            document.getElementById('dateDisplayTop').textContent = formatDateForDisplay(dateStr);
            document.getElementById('prevBtn').disabled = currentIndex === 0;
            document.getElementById('nextBtn').disabled = currentIndex === allDates.length - 1;
            renderDay(dateStr);
            updateProgress();
        }

        /**
         * Finds the index of the current date in the allDates array.
         * @returns {number} The index, or -1 if not found.
         */
        function findTodayIndex() {
            const today = new Date();
            const todayFormatted = formatDateDDMMYY(today);
            return allDates.indexOf(todayFormatted);
        }
        
        /**
         * Updates the progress tracker display.
         */
        function updateProgress() {
            const doneIds = JSON.parse(localStorage.getItem('doneIds') || '[]');
            const completedCount = doneIds.length;
            const totalCount = events.length;
            const percentage = totalCount > 0 ? Math.round((completedCount / totalCount) * 100) : 0;
            const progressText = `${completedCount} of ${totalCount} activities complete (${percentage}%)`;
            document.getElementById('progressDisplay').textContent = progressText;
        }

        /**
         * Initializes the application by fetching data and setting up event listeners.
         */
        async function init() {
            try {
                const response = await fetch('Itinerary.csv');
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                const txt = await response.text();
                
                events = parseEventsFromCustomCSV(csvToRows(txt));
                grouped = groupByDate(events);
                allDates = Array.from(grouped.keys());
                allDates.sort((a, b) => {
                    const [da, ma, ya] = a.split('-').map(x => parseInt(x));
                    const [db, mb, yb] = b.split('-').map(x => parseInt(x));
                    return new Date(2000 + ya, ma - 1, da) - new Date(2000 + yb, mb - 1, db);
                });

                currentIndex = findTodayIndex();
                if(currentIndex === -1) currentIndex = 0;

                document.getElementById('prevBtn').addEventListener('click', () => {
                    if (currentIndex > 0) {
                        currentIndex--;
                        showItinerary();
                    }
                });

                document.getElementById('nextBtn').addEventListener('click', () => {
                    if (currentIndex < allDates.length - 1) {
                        currentIndex++;
                        showItinerary();
                    }
                });

                document.getElementById('todayBtn').addEventListener('click', () => {
                    const today = new Date();
                    const firstDate = new Date(`20${allDates[0].slice(-2)}`, allDates[0].slice(3, 5) - 1, allDates[0].slice(0, 2));
                    
                    if (today.getTime() < firstDate.getTime()) {
                        showCountdown();
                    } else {
                        const todayIndex = findTodayIndex();
                        if (todayIndex !== -1) {
                            currentIndex = todayIndex;
                        } else {
                            currentIndex = allDates.length - 1;
                        }
                        showItinerary();
                    }
                });
                
                document.getElementById('completedBtn').addEventListener('click', () => {
                    showCompleted();
                });
                
                document.getElementById('nextStopsBtn').addEventListener('click', () => {
                    showNextStops();
                });

                document.getElementById('backBtn').addEventListener('click', () => {
                    showItinerary();
                });
                
                document.getElementById('backFromCompletedBtn').addEventListener('click', () => {
                    showItinerary();
                });
                
                document.getElementById('backFromNextBtn').addEventListener('click', () => {
                    showItinerary();
                });

                // Initial render based on the current date
                const today = new Date();
                const firstDate = new Date(`20${allDates[0].slice(-2)}`, allDates[0].slice(3, 5) - 1, allDates[0].slice(0, 2));
                if (today.getTime() < firstDate.getTime()) {
                    showCountdown();
                } else {
                    showItinerary();
                }

            } catch (error) {
                console.error("Error loading itinerary:", error);
                document.getElementById('list').innerHTML = `<div class="empty">Error loading itinerary. It seems the file "Itinerary.csv" could not be accessed. Please ensure it is present.</div>`;
            }
        }

        init();
    </script>
</body>
</html>
